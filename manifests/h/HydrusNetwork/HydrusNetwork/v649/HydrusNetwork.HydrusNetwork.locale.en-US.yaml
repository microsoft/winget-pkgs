# Created with komac v2.14.0
# yaml-language-server: $schema=https://aka.ms/winget-manifest.defaultLocale.1.10.0.schema.json

PackageIdentifier: HydrusNetwork.HydrusNetwork
PackageVersion: v649
PackageLocale: en-US
Publisher: Hydrus Network
PublisherUrl: https://github.com/hydrusnetwork/hydrus
PublisherSupportUrl: https://github.com/hydrusnetwork/hydrus/issues
PrivacyUrl: https://hydrusnetwork.github.io/hydrus/privacy.html
Author: Hydrus Network
PackageName: Hydrus Network
PackageUrl: https://github.com/hydrusnetwork/hydrus
License: WTFPL
LicenseUrl: https://github.com/hydrusnetwork/hydrus/blob/HEAD/license.txt
Copyright: Copyright (C) 2011 Hydrus Developer
CopyrightUrl: https://github.com/hydrusnetwork/hydrus/blob/master/license.txt
ShortDescription: A personal booru-style media tagger that can import files and tags from your hard drive and popular websites. Content can be shared with other users via user-run servers.
Description: |-
  The hydrus network client is an application written for Anon and other internet-fluent media nerds who have large image/swf/webm collections.
  It browses with tags instead of folders, a little like a booru on your desktop. Advanced users can share tags and files anonymously through custom servers that any user may run.
  Everything is free and privacy is the first concern. Executable releases are available for Windows, Linux, and macOS.
  The program is in python, so you can also run it straight from the source code.
Moniker: hydrus-network
Tags:
- booru
- cross-platform
- image-database
ReleaseNotes: |-
  big user submission
  - a user has sent in a large set of command palette, page navigation, and rating updates--
  - when you edit a rating service in services->manage services, there is now a live and interactable rating widget that updates to show your chosen shapes and colours!
  - when you edit the rating sizes in options->ratings, there are similar live rating widgets that will dynamically resize to the widths and heights you choose!
  - under options->command palette, you can now add your 'page history' to the initial results
  - under options->command palette, you can now add your 'favourite searches' to the initial results! I love how this works
  - you can also limit the number of search results, which appears to reduce command palette lag significantly on clients with many hundreds of pages
  - and you can also re-order the results by their type
  - under pages->history, you can now clear the history
  - options->gui pages now allows you to limit the number of pages kept in the history
  - the media viewer's zoom options menu has even more granular control over remembering zoom options with a new setting to allow updating the default settings by clicking the menu (rather than it being transient to that media viewer instance)
  - there's also a "do not recenter media on window resize" option (allowing you to now turn this behaviour off), and in options->media playback too
  - 'page of pages' now automatically put a â†“ suffix at the end of their name label. you can change the suffix or turn it off under options->pages,
  user client api
  - the user also added /get_service_rating_svg to the Client API, which lets you pull the svg used for a rating. there is help for this
  - I wrote a unit test for this
  - Client API version is now 83
  misc
  - every ffmpeg call we make now flags ffmpeg to fail on the first error. we encountered a not-fun issue a week ago when certain JpegXLs were putting ffmpeg into an infinite error loop on a 'is animated' pre-import test. this loop is now broken instantly, but if a similar issue comes up, all external process calls also now cancel out if they take longer than (usually) fifteen seconds. I am not sure how prevalent errors are in normal videos, so let me know if many new videos suddenly get no thumbnails or something. this might be something we eventually want to tune (issue #1912)
  - the animated jxl test is re-activated
  - I renamed the confusing 'all my files' to 'combined local file domains' for new users a couple weeks ago. nothing exploded, so all existing users are being renamed today
  - across the program, the places where you locally store files and tags are now called 'local file/tag domain'. there was a mix of 'service' and 'domain' before, and I am trying to harmonise
  - fixed some traceback errors related to middle-clicking stub system predicates (like 'system:rating' in the initial file auto-complete dropdown), where it wasn't checking for the stub status and couldn't navigate what to do next
  - fixed importing pdfs (or any other file format) if the thumbnail creation fails silently with a null result
  - the archive/delete and duplicate filters, which have a 'want to commit all this?' interstitial dialog on close, no longer tell the parent media window to focus the current media before the interstitial is finished. previously, if you started this process while looking at a video, you'd suddenly get that video playing in the background while thinking about hitting 'commit', and if you decided to cancel out and go back to filtering, the underlying thumbnail page would still have that video highlighted. since the archive/delete job often clears out processed thumbnails right after, this would IRL be a small blip of noise and CPU as the video was loaded and then unloaded. I'm pretty sure this was the cause of the odd mpv lock-up we had a few weeks ago when testing out the new mpv async interface, because of a quick mpv swish before I had code to handle early unload. anyway, this annoyance should be fixed now--the 'play this mediia' signal is sent only on a confirmed media viewer close signal. I brushed up the specific logic about which media to send from an archive/delete, too--depending on which files are set to hide after processing, it'll try and send a different appropriave focus media, often none at all
  - options->tag presentation has a pair of advanced new options that set the default 'tag display type' of the normal page sidebar taglist and the media viewer taglist. I also fixed a rendering bug with this experimental system; changing the tag display type of a taglist now corrects the 'render for user' state for things like whether to display namespaces or custom namespace separators no matter what the starting state of the list was
  clever rating search
  - in system:rating, if you have more than one rating service, there is now a powerful compound 'advanced rating' predicate. it lets you do 'system:all of x are rated' and 'system:any of x are rated', where x is a new widget that lets you select all rating services, just like/dislike, numerical, and/or inc/dec, or individual services in a checkbox list. there is also 'system:only x (amongst y) are rated', where y is a different set of rating services where all of x need to be rated but none of the remainder of y can be rated, with the classical example being x being one rating service and y being all of them, for finding files that are only rated on that service
  - all these support 'not rated' too, so you can now find files that have no rating anywhere, somewhere, or within a specific selection (e.g. system:'only favourites not rated out of all my like/dislike ratings')
  - I assembled this system through sheer force of will and there may be bugs. let me know how it goes
  - if you enter 'only x amongst x rated', i.e. with an uninteresting y, it swaps in 'all x rated'. there are probably some more optimisations if you enter certain one-service edge cases
  - I may be convinced to add an 'only-or' variant, but only if there is a real scenario for it and we can come up with clean nomenclature
  duplicates
  - the auto-resolution rules review list (in a normal duplicates page) now grows and shrinks depending on the number of rules
  - on the first load of a page's auto-resolution rules, the list panel now starts disabled and there's a little 'initialising...' text
  subprocess improvements
  - all subprocess calls (when hydrus opens another program, like ffmpeg, or asks your system to open a file externally) now happen in one place with cleaner code and better error handling
  - subprocess calls that launch a potentially long-lived program that we don't care much to talk to again, like an external music player run from 'open externally', now hand the process handles to a maintenance list to be polled every few minutes in normal memory maintenance. should be cleaner reaping and fewer zombies in non-Windows environments
  - all subprocess calls that we do care for an answer from now have a timeout. if they exceed that time, they are terminated, killed, reaped, and stdout and stderr reported nicely
  - all ffmpeg file metadata calls now have special handling for timeout problems, generally raising the 'damaged or unusual file' exception, which lets thumbnail gen and so on know to use a default thumb. timeout is usually 15 seconds
  - wrote a separate wrapper for subprocess calls that stream data over a longer time (video, PCM rendering). these use a context manager to ensure the process is terminated and reaped cleanly and also support timeout errors on each individual pipe chunk read
  - the calls that create streaming ffmpeg renderers for some more unusual thumbnail gen jobs now properly close the underlying process cleanly
  - all subprocess debug reporting mode stuff now happens in all cases
  better image prefetching
  - a different user sent in some ideas for smarter image prefetching/pinning, particularly to deal with very-full-cache situations (like when you scroll through ten 12,000x14,000 images), and I worked on it a bit. I ended up not using the pinning for now, but I've improved prefetch intelligence significantly
  - when canvases do a neighbour prefetch, they now only perform one prefetch render at a time, alternating with next/previous/next/previous. if any of the prior prefetches are still rendering, we wait until they are done before we start another one. this saves time and memory, improves nearest-next availability when files are slow to load, and improves stability in extreme cases
  - the prefetch medias are now submitted and weighed together in order every time, and if doing the next prefetch load would cause the total prefetch size to exceed the percentage allowed in 'speed and memory', we stop prefetching at that point. this stops excessive cache churn when we have lots of extremely-large-file prefetch going on. this saves time, memory, and improves stability in extreme cases
  - the 'how much cache size to prefetch' option in 'speed and memory' is altered as a result. it is no longer per file, but for the whole prefetch and the allowed settable range is expanded. the default value is increased from 15% to 25%, and any user who has an existing value less than 25% will be bumped up. with the default options (25% of 1GB image cache), this means about 10x 4k images
  - the 'are your prefetch numbers good?' bit in the next section now gives warnings for explicit 1080p/4k counts, so, if you are set to prefetch 4 total files, and they and the current file at 4k would exceed the prefetch threshold, it'll tell you
  - the main image prefetch routine also now explicitly asks the cache if it can free up easy space to fit a new prefetch in before firing the prefetch request. images that are currently rendering are counted as 'not easy to free'. this will stop the cache churning when there's big stuff already hitting the CPU
  - cache logic is generally improved a little bit
ReleaseNotesUrl: https://github.com/hydrusnetwork/hydrus/releases/tag/v649
PurchaseUrl: https://hydrusnetwork.github.io/hydrus/support.html
Documentations:
- DocumentLabel: FAQ
  DocumentUrl: https://hydrusnetwork.github.io/hydrus/faq.html
ManifestType: defaultLocale
ManifestVersion: 1.10.0
